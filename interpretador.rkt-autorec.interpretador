#lang eopl

;===============================================================================
; PUNTO 1: DEFINICIÓN DEL LENGUAJE Y SU GRAMÁTICA
;===============================================================================

(define-datatype valor-denotado valor-denotado?
  (numero-val (num number?))
  (texto-val (txt string?))
  (booleano-val (bool boolean?))
  (proc-val (proc proc?)))

(define-datatype proc proc?
  (cerradura
   (ids (list-of symbol?))
   (cuerpo expresion?)
   (env ambiente?)))

(define-datatype expresion expresion?
  (numero-lit (num number?))
  (texto-lit (txt string?))
  (var-exp (id symbol?))
  (primapp-bin-exp (exp1 expresion?) (prim-binaria symbol?) (exp2 expresion?))
  (primapp-un-exp (prim-unaria symbol?) (exp expresion?))
  (condicional-exp (test-exp expresion?) (true-exp expresion?) (false-exp expresion?))
  (variableLocal-exp (ids (list-of symbol?)) (exps (list-of expresion?)) (cuerpo expresion?))
  (procedimiento-exp (ids (list-of symbol?)) (cuerpo expresion?))
  (app-exp (rator expresion?) (rands (list-of expresion?)))
  (letrec-exp
   (proc-nombres (list-of symbol?))
   (proc-parametros (list-of (list-of symbol?)))
   (proc-cuerpos (list-of expresion?))
   (letrec-cuerpo expresion?)))

(define evaluar-expresion
  (lambda (exp env)
    (cases expresion exp
      (numero-lit (num) (numero-val num))
      (texto-lit (txt) (texto-val txt))
      (var-exp (id) (buscar-variable id env))
      (primapp-bin-exp (exp1 prim exp2)
       (let ((val1 (evaluar-expresion exp1 env))
             (val2 (evaluar-expresion exp2 env)))
         (aplicar-primitiva-binaria prim val1 val2)))
      (primapp-un-exp (prim exp)
       (let ((val (evaluar-expresion exp env)))
         (aplicar-primitiva-unaria prim val)))
      
      ;=========================================================================
      ; CASO CONDICIONAL
      ;=========================================================================
      (condicional-exp (test-exp true-exp false-exp)
        (let ((test-val (evaluar-expresion test-exp env)))
          (if (valor-verdad? test-val)
              (evaluar-expresion true-exp env)
              (evaluar-expresion false-exp env))))
      
      ;=========================================================================
      ; CASO VARIABLES LOCALES
      ;=========================================================================
      (variableLocal-exp (ids exps cuerpo)
          (if (null? ids)
            (evaluar-expresion cuerpo env)
            (let ((val1 (evaluar-expresion (car exps) env)))
             (let ((nuevo-env (extender-ambiente (list (car ids)) (list val1) env)))
              (evaluar-expresion
               (variableLocal-exp (cdr ids) (cdr exps) cuerpo)
                nuevo-env)))))
      
      ;=========================================================================
      ; CASO PROCEDIMIENTO
      ;=========================================================================
      (procedimiento-exp (ids cuerpo)
        (proc-val (cerradura ids cuerpo env)))

      (app-exp (rator rands)
        (let ([procedimiento (evaluar-expresion rator env)]
              [argumentos (map (lambda (arg) (evaluar-expresion arg env)) rands)])
          (cases valor-denotado procedimiento
            (proc-val (proc)
              (aplicar-procedimiento proc argumentos))
            (else (eopl:error 'evaluar-expresion "Error: Se intentó llamar a algo que no es un procedimiento: ~s" procedimiento)))))
      
      ;=========================================================================
      ; CASO RECURSION
      ;=========================================================================
      (letrec-exp (proc-nombres p-parametros p-cuerpos letrec-cuerpo)
        (evaluar-expresion
         letrec-cuerpo
         (extender-ambiente-recursivamente proc-nombres p-parametros p-cuerpos env))) )))

; --- Aplicación de Primitivas ---
(define aplicar-primitiva-binaria
  (lambda (prim val1 val2)
    (cases valor-denotado val1
      (numero-val (n1)
        (cases valor-denotado val2
          (numero-val (n2)
            (cond
              [(eqv? prim '+) (numero-val (+ n1 n2))]
              [(eqv? prim '~) (numero-val (- n1 n2))]
              [(eqv? prim '/) (numero-val (/ n1 n2))]
              [(eqv? prim '*) (numero-val (* n1 n2))]
              [else (eopl:error 'aplicar-primitiva-binaria "Operador no válido para números: ~s" prim)]))
          (else (eopl:error 'aplicar-primitiva-binaria "El segundo operando no es un número: ~s" val2))))
      (texto-val (s1)
        (cases valor-denotado val2
          (texto-val (s2)
            (if (eqv? prim 'concat)
                (texto-val (string-append s1 s2))
                (eopl:error 'aplicar-primitiva-binaria "Operador no válido para textos: ~s" prim)))
          (else (eopl:error 'aplicar-primitiva-binaria "El segundo operando no es un texto: ~s" val2))))
      (else (eopl:error 'aplicar-primitiva-binaria "Tipo no soportado para operaciones binarias: ~s" val1)))))

(define aplicar-primitiva-unaria
  (lambda (prim val)
    (cases valor-denotado val
      (numero-val (n)
        (cond
          [(eqv? prim 'add1) (numero-val (+ n 1))]
          [(eqv? prim 'sub1) (numero-val (- n 1))]
          [else (eopl:error 'aplicar-primitiva-unaria "Operador no válido para números: ~s" prim)]))
      (texto-val (s)
        (if (eqv? prim 'longitud)
            (numero-val (string-length s))
            (eopl:error 'aplicar-primitiva-unaria "Operador no válido para textos: ~s" prim)))
      (else (eopl:error 'aplicar-primitiva-unaria "Tipo no soportado para operaciones unarias: ~s" val)))))


; --- Aplicación de Procedimiento ---
(define aplicar-procedimiento
  (lambda (un-proc args)
    (cases proc un-proc
      (cerradura (ids cuerpo env-guardado)
        (let ((nuevo-env (extender-ambiente ids args env-guardado)))
          (evaluar-expresion cuerpo nuevo-env))))))

;===============================================================================
; PUNTO 2: GESTIÓN DEL AMBIENTE
;===============================================================================

(define ambiente-inicial
  (list 
        (cons '@pi (numero-val 3.14159))
        (cons '@a (numero-val 1))
        (cons '@b (numero-val 2))
        (cons '@c (numero-val 3))
        (cons '@d (texto-val "hola"))
        (cons '@e (texto-val "FLP"))))

(define ambiente?
  (lambda (x)
    (list? x)))

(define buscar-variable
  (lambda (id env)
    (if (null? env)
        (eopl:error 'buscar-variable "La variable no ha sido definida: ~s" id)
        (let ((primer-elemento (car env)))
          (if (eqv? (car primer-elemento) 'rec-ambiente)
            
              (let* ((nombres (cadr primer-elemento))
                     (parametros (caddr primer-elemento))
                     (cuerpos (cadddr primer-elemento))
                     (pos (list-find-position id nombres)))
                (if pos
              
                    (proc-val
                     (cerradura
                      (list-ref parametros pos)
                      (list-ref cuerpos pos)
                      env))
                    (buscar-variable id (cdr env))))
           
              (let ((par primer-elemento))
                (if (eqv? (car par) id)
                    (cdr par)
                    (buscar-variable id (cdr env)))))))))

(define extender-ambiente-recursivamente
  (lambda (proc-nombres p-parametros p-cuerpos env)
    (cons (list 'rec-ambiente proc-nombres p-parametros p-cuerpos) env)))

;===============================================================================
; FUNCIONES AUXILIARES
;===============================================================================
(define extender-ambiente
  (lambda (ids vals env)
    (if (null? ids)
        env
        (extender-ambiente 
         (cdr ids) 
         (cdr vals)
         (cons (cons (car ids) (car vals)) env)))))

(define list-find-position
  (lambda (elem lst)
    (cond
      ((null? lst) #f)
      ((eqv? elem (car lst)) 0)
      (else (let ((res (list-find-position elem (cdr lst))))
              (if res (+ 1 res) #f))))))

;===============================================================================
; PUNTO 3: IMPLEMENTACIÓN DE LÓGICA BOOLEANA
;===============================================================================
(define valor-verdad?
  (lambda (valor)
    (cases valor-denotado valor
      (numero-val (num)
        (not (zero? num))) ; La función zero? es una forma limpia de escribir (= num 0)
      (else
       (eopl:error 'valor-verdad? "Se esperaba un valor numérico, pero se recibió: ~s" valor)))))

;===============================================================================
; PARSER
;===============================================================================

; --- Funciones auxiliares para el parser ---
(define es-primitiva-binaria?
  (lambda (op)
    (memv op '(+ ~ / * concat))))

(define es-primitiva-unaria?
  (lambda (op)
    (memv op '(longitud add1 sub1))))

(define sublist
  (lambda (ls start end)
    (cond
      ((>= start end) '())
      (else (cons (list-ref ls start) (sublist ls (+ start 1) end))))))

(define parse-expression
  (lambda (datum)
    (cond
      ;; ---------------------------------------
      ;; Literales y variables
      ;; ---------------------------------------
      ((number? datum) (numero-lit datum))
      ((string? datum) (texto-lit datum))
      ((symbol? datum) (var-exp datum))

      ;; ---------------------------------------
      ;; Expresiones compuestas (listas)
      ;; ---------------------------------------
      ((pair? datum)
       (let ((head (car datum)))
         (cond
           ;; -----------------------
           ;; Condicional
           ;; -----------------------
           ((eqv? head 'Si)
            (if (and (= (length datum) 7)
                     (eqv? (list-ref datum 2) 'entonces)
                     (eqv? (list-ref datum 4) 'sino)
                     (eqv? (list-ref datum 6) 'finSI))
                (condicional-exp
                 (parse-expression (cadr datum))
                 (parse-expression (list-ref datum 3))
                 (parse-expression (list-ref datum 5)))
                (eopl:error 'parse-expression "Condicional 'Si' mal formado: ~s" datum)))

           ;; -----------------------
           ;; Declarar variables locales
           ;; -----------------------
           ((eqv? head 'declarar)
            (let ((bindings (cadr datum))
                  (body (caddr datum)))
              (variableLocal-exp
               (map car bindings)                        ; nombres de variables
               (map (lambda (b) (parse-expression (caddr b))) bindings) ; valores iniciales
               (parse-expression body))))

           ;; -----------------------
           ;; Procedimiento
           ;; -----------------------
           ((eqv? head 'procedimiento)
            (if (and (= (length datum) 5)
                     (eqv? (list-ref datum 2) 'haga)
                     (eqv? (list-ref datum 4) 'finProc))
                (procedimiento-exp
                 (cadr datum)                  ; lista de parámetros
                 (parse-expression (caddr (cdr datum)))) ; cuerpo
                (eopl:error 'parse-expression "Procedimiento mal formado: ~s" datum)))

           ;; -----------------------
           ;; Evaluar aplicación de procedimiento
           ;; -----------------------
           ((eqv? head 'evaluar)
            (let ((len (length datum)))
              (if (and (> len 2)
                       (eqv? (list-ref datum (- len 1)) 'finEval))
                  (app-exp
                   (parse-expression (cadr datum))
                   (map parse-expression (sublist datum 2 (- len 1))))
                  (eopl:error 'parse-expression "'evaluar' mal formado: ~s" datum))))

           ;; -----------------------
           ;; Letrec
           ;; -----------------------
          ((eqv? head 'letrec)
           (let ((bindings (cadr datum))
                 (letrec-body (caddr datum)))
             (let ((proc-nombres (map car bindings))
                   (proc-parametros (map cadr bindings))
        
                   (proc-cuerpos (map (lambda (b)
                                        ; Corregido para tomar el 4to elemento como cuerpo
                                        (parse-expression (list-ref b 3)))
                                      bindings)))
               (letrec-exp proc-nombres proc-parametros proc-cuerpos
                           (parse-expression letrec-body)))))

           ;; -----------------------
           ;; Primitivas unarias
           ;; -----------------------
           ((es-primitiva-unaria? head)
            (if (= (length datum) 2)
                (primapp-un-exp head (parse-expression (cadr datum)))
                (eopl:error 'parse-expression "Operación unaria mal formada: ~s" datum)))

           ;; -----------------------
           ;; Primitivas binarias
           ;; -----------------------
           ((and (= (length datum) 3) (es-primitiva-binaria? (cadr datum)))
            (primapp-bin-exp
             (parse-expression (car datum))
             (cadr datum)
             (parse-expression (caddr datum))))

           ;; -----------------------
           ;; Caso no reconocido
           ;; -----------------------
           (else (eopl:error 'parse-expression "Expresión de lista no reconocida: ~s" datum)))))

      ;; ---------------------------------------
      ;; Sintaxis no válida
      ;; ---------------------------------------
      (else (eopl:error 'parse-expression "Sintaxis inválida: ~s" datum)))))

;===============================================================================
; PRUEBAS (UTILIZANDO EL PARSER)
;===============================================================================
(define run
  (lambda (expresion-concreta)
    (let ((expresion-abstracta (parse-expression expresion-concreta)))
      (evaluar-expresion expresion-abstracta ambiente-inicial))))

;;========================================
;; Pruebas de búsqueda de variables
;;========================================
(eopl:printf "--- Pruebas de búsqueda de variables ---\n")
(eopl:printf "~s\n" (run '@a))
(eopl:printf "~s\n" (run '@b))
(eopl:printf "~s\n" (run '@e))

;;========================================
;; Pruebas de operaciones
;;========================================
(eopl:printf "\n--- Pruebas de operaciones ---\n")
(eopl:printf "~s\n" (run '(@a + @b)))
(eopl:printf "~s\n" (run '(@d concat @e)))
(eopl:printf "~s\n" (run '(longitud @d)))
(eopl:printf "~s\n" (run '(add1 @c)))

;;========================================
;; Pruebas de booleanos
;;========================================
(eopl:printf "\n--- Pruebas de booleanos (valor-verdad?) ---\n")
(eopl:printf "~s\n" (valor-verdad? (numero-val 5)))
(eopl:printf "~s\n" (valor-verdad? (numero-val 0)))
(eopl:printf "~s\n" (valor-verdad? (numero-val -1)))

;;========================================
;; Pruebas condicionales
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Pruebas condicionales \n")
(eopl:printf "========================================\n\n")

(eopl:printf "1. Si (2+4) entonces 2 sino 3 finSI\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(Si (2 + 4) entonces 2 sino 3 finSI)))

(eopl:printf "\n2. Si (longitud(@d) ~ 4) entonces 2 sino 3 finSI\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(Si ((longitud @d) ~ 4) entonces 2 sino 3 finSI)))

;;========================================
;; Pruebas variables locales
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Pruebas variables locales \n")
(eopl:printf "========================================\n\n")

(eopl:printf "1. declarar (@x=2;@y=3;@a=7) { (@a+(@x ~ @y)) }\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(declarar ((@x = 2) (@y = 3) (@a = 7))
         (@a + (@x ~ @y)))))

(eopl:printf "\n2. declarar (@x=2;@y=3;@a=7) { (@a+@b) }\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(declarar ((@x = 2) (@y = 3) (@a = 7))
         (@a + @b))))

;;========================================
;; Pruebas recursión (factorial)
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Pruebas de Recursión (Factorial)\n")
(eopl:printf "========================================\n\n")

(eopl:printf "1. Factorial de 5\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(letrec ((@factorial (@n) haga
                   (Si @n
                       entonces (@n * (evaluar @factorial (@n ~ 1) finEval))
                       sino 1
                       finSI)
                   finProc))
          (evaluar @factorial 5 finEval))))

(eopl:printf "\n2. Factorial de 1\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(letrec ((@factorial (@n) haga
                   (Si @n
                       entonces (@n * (evaluar @factorial (@n ~ 1) finEval))
                       sino 1
                       finSI)
                   finProc))
          (evaluar @factorial 1 finEval))))

;;========================================
;; Área de un círculo
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Prueba de Procedimiento: Área de un Círculo\n")
(eopl:printf "========================================\n\n")

(eopl:printf "Cálculo del área para un radio de 2.5\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(declarar ((@radio = 2.5)
                   (@areaCirculo = (procedimiento (@r) haga (@pi * (@r * @r)) finProc)))
          (evaluar @areaCirculo @radio finEval))))

;;========================================
;; Resta y multiplicación solo con ADD1 y SUB1
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Resta y multiplicación con primitivas mínimas\n")
(eopl:printf "========================================\n\n")

(eopl:printf "Cálculo de la resta recursiva para (10, 3):\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(letrec ((@restar (@a @b) haga
                   (Si @b
                       entonces (evaluar @restar (sub1 @a) (sub1 @b) finEval)
                       sino @a
                       finSI)
                   finProc))
          (evaluar @restar 10 3 finEval))))

(eopl:printf "\nCálculo de la multiplicación recursiva para (10, 3):\n")
(eopl:printf "   Resultado: ~s\n"
  (run '(letrec ((@sumar (@x @y) haga
                   (Si @y
                       entonces (evaluar @sumar (add1 @x) (sub1 @y) finEval)
                       sino @x
                       finSI)
                   finProc)
                  (@multiplicar (@a @b) haga
                   (Si @b
                       entonces (evaluar @sumar @a (evaluar @multiplicar @a (sub1 @b) finEval) finEval)
                       sino 0
                       finSI)
                   finProc))
          (evaluar @multiplicar 10 3 finEval))))

;;========================================
;; Decorador simple
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Prueba decorador simple\n")
(eopl:printf "========================================\n\n")

(eopl:printf "Resultado: ~s\n"
  (run '(declarar
          ((@integrantes = (procedimiento () haga "Joel-Allan-Manuel" finProc))
           (@saludar = (procedimiento (@func) haga
                         (procedimiento () haga
                           ("Hola:" concat (evaluar @func finEval))
                           finProc)
                         finProc))
           (@decorate = (evaluar @saludar @integrantes finEval)))
          (evaluar @decorate finEval))))

;;========================================
;; Decorador con parámetros
;;========================================
(eopl:printf "\n========================================\n")
(eopl:printf "Prueba decorador con parámetros\n")
(eopl:printf "========================================\n\n")

(eopl:printf "Resultado: ~s\n"
  (run '(declarar
          ((@integrantes = (procedimiento () haga "Manuel-Joel-Allan" finProc))
           (@saludar = (procedimiento (@func) haga
                         (procedimiento (@sufijo) haga
                           (("Hola:" concat (evaluar @func finEval)) concat @sufijo)
                           finProc)
                         finProc))
           (@decorate = (evaluar @saludar @integrantes finEval)))
          (evaluar @decorate "-ProfesoresFLP" finEval))))
